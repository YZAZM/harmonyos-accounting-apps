import { relationalStore, ValuesBucket } from '@kit.ArkData';
import { BusinessError } from '@kit.BasicServicesKit';

// æ•°æ®åº“é…ç½®
const DB_NAME = 'autobill.db';
const DB_VERSION = 1;

// è¡¨åå¸¸é‡
export const TABLE_TRANSACTIONS = 'transactions';
export const TABLE_CATEGORIES = 'categories';
export const TABLE_AUTO_RULES = 'auto_rules';

// æ•°æ®åº“ç®¡ç†ç±»
export class DatabaseManager {
  private static instance: DatabaseManager;
  private rdbStore: relationalStore.RelationalStore | null = null;

  static getInstance(): DatabaseManager {
    if (!DatabaseManager.instance) {
      DatabaseManager.instance = new DatabaseManager();
    }
    return DatabaseManager.instance;
  }

  // åˆå§‹åŒ–æ•°æ®åº“
  async init(): Promise<void> {
    const config: relationalStore.StoreConfig = {
      name: DB_NAME,
      securityLevel: relationalStore.SecurityLevel.S1,
      encrypt: false
    };

    try {
      this.rdbStore = await relationalStore.getRdbStore(getContext(), config);
      await this.createTables();
      await this.initDefaultCategories();
      console.info('æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ');
    } catch (err) {
      console.error('æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', JSON.stringify(err));
      throw err;
    }
  }

  // åˆ›å»ºè¡¨
  private async createTables(): Promise<void> {
    // è´¦ç›®è¡¨
    const createTransactionsSQL = `
      CREATE TABLE IF NOT EXISTS ${TABLE_TRANSACTIONS} (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        amount REAL NOT NULL,
        type INTEGER NOT NULL DEFAULT 0,
        category TEXT NOT NULL,
        merchant TEXT,
        pay_method TEXT,
        transaction_time INTEGER NOT NULL,
        remark TEXT,
        source_app TEXT,
        created_at INTEGER DEFAULT CURRENT_TIMESTAMP,
        updated_at INTEGER
      )
    `;

    // åˆ†ç±»è¡¨
    const createCategoriesSQL = `
      CREATE TABLE IF NOT EXISTS ${TABLE_CATEGORIES} (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        icon TEXT,
        type INTEGER NOT NULL DEFAULT 0,
        sort_order INTEGER DEFAULT 0,
        is_default INTEGER DEFAULT 0
      )
    `;

    // è‡ªåŠ¨è¯†åˆ«è§„åˆ™è¡¨
    const createAutoRulesSQL = `
      CREATE TABLE IF NOT EXISTS ${TABLE_AUTO_RULES} (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        app_package TEXT NOT NULL,
        page_pattern TEXT,
        amount_selector TEXT,
        merchant_selector TEXT,
        is_active INTEGER DEFAULT 1
      )
    `;

    await this.executeSQL(createTransactionsSQL);
    await this.executeSQL(createCategoriesSQL);
    await this.executeSQL(createAutoRulesSQL);
  }

  // åˆå§‹åŒ–é»˜è®¤åˆ†ç±»
  private async initDefaultCategories(): Promise<void> {
    const count = await this.queryCount(TABLE_CATEGORIES);
    if (count > 0) return;

    const defaultCategories = [
      { name: 'é¤é¥®', icon: 'ğŸ½ï¸', type: 0, sort_order: 1, is_default: 1 },
      { name: 'äº¤é€š', icon: 'ğŸš—', type: 0, sort_order: 2, is_default: 1 },
      { name: 'è´­ç‰©', icon: 'ğŸ›ï¸', type: 0, sort_order: 3, is_default: 1 },
      { name: 'å¨±ä¹', icon: 'ğŸ®', type: 0, sort_order: 4, is_default: 1 },
      { name: 'å±…ä½', icon: 'ğŸ ', type: 0, sort_order: 5, is_default: 1 },
      { name: 'åŒ»ç–—', icon: 'ğŸ¥', type: 0, sort_order: 6, is_default: 1 },
      { name: 'æ•™è‚²', icon: 'ğŸ“š', type: 0, sort_order: 7, is_default: 1 },
      { name: 'å·¥èµ„', icon: 'ğŸ’°', type: 1, sort_order: 1, is_default: 1 },
      { name: 'å¥–é‡‘', icon: 'ğŸ', type: 1, sort_order: 2, is_default: 1 },
      { name: 'æŠ•èµ„', icon: 'ğŸ“ˆ', type: 1, sort_order: 3, is_default: 1 }
    ];

    for (const category of defaultCategories) {
      await this.insert(TABLE_CATEGORIES, category as ValuesBucket);
    }
  }

  // æ‰§è¡ŒSQL
  private async executeSQL(sql: string): Promise<void> {
    if (!this.rdbStore) return;
    try {
      await this.rdbStore.execute(sql);
    } catch (err) {
      console.error('æ‰§è¡ŒSQLå¤±è´¥:', sql, JSON.stringify(err));
    }
  }

  // æ’å…¥æ•°æ®
  async insert(table: string, values: ValuesBucket): Promise<number> {
    if (!this.rdbStore) return -1;
    try {
      const rowId = await this.rdbStore.insert(table, values);
      return rowId;
    } catch (err) {
      console.error('æ’å…¥æ•°æ®å¤±è´¥:', JSON.stringify(err));
      return -1;
    }
  }

  // æ›´æ–°æ•°æ®
  async update(table: string, values: ValuesBucket, predicates: relationalStore.RdbPredicates): Promise<number> {
    if (!this.rdbStore) return 0;
    try {
      const count = await this.rdbStore.update(values, predicates);
      return count;
    } catch (err) {
      console.error('æ›´æ–°æ•°æ®å¤±è´¥:', JSON.stringify(err));
      return 0;
    }
  }

  // åˆ é™¤æ•°æ®
  async delete(predicates: relationalStore.RdbPredicates): Promise<number> {
    if (!this.rdbStore) return 0;
    try {
      const count = await this.rdbStore.delete(predicates);
      return count;
    } catch (err) {
      console.error('åˆ é™¤æ•°æ®å¤±è´¥:', JSON.stringify(err));
      return 0;
    }
  }

  // æŸ¥è¯¢æ•°æ®
  async query(predicates: relationalStore.RdbPredicates, columns?: string[]): Promise<relationalStore.ResultSet> {
    if (!this.rdbStore) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }
    return await this.rdbStore.query(predicates, columns);
  }

  // æŸ¥è¯¢æ•°é‡
  private async queryCount(table: string): Promise<number> {
    if (!this.rdbStore) return 0;
    const predicates = new relationalStore.RdbPredicates(table);
    const resultSet = await this.rdbStore.query(predicates, ['COUNT(*) as count']);
    let count = 0;
    if (resultSet.goToFirstRow()) {
      count = resultSet.getLong(0);
    }
    resultSet.close();
    return count;
  }

  // å…³é—­æ•°æ®åº“
  async close(): Promise<void> {
    if (this.rdbStore) {
      await this.rdbStore.close();
      this.rdbStore = null;
    }
  }
}

export default DatabaseManager.getInstance();
